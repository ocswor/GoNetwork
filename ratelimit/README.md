# 固定窗口控制

## 限流
   * 限制对象的访问次数 比如1000次/秒，10000/分钟, 1分钟就是窗口的大小
   
## 窗口的划分
   

   * 将1970年到现在的时间当做一条线.
        
      ```
     println(time.Now().Unix()) 表示当前的时间总数  
     r := int64(time.Now().Unix() / int64(fillInterval.Seconds())) // 表示当前属于哪个窗口
      ```  
     假如每一个窗口的大小固定,那么在这条线线上的某一秒属于的某个窗口就是固定的
     
     将窗口的时间段转化成一个key值. 通过redis记录key值,就可以记录当前窗口范围内访问的个数.
     
## 固定窗口的缺点
   因为窗口一旦固定住了,而请求时间不固定.
   假如一个 限流要求是  10000请求/分钟
   假如一个一个固定窗口的(A时间段)前30秒访问了100个请求,(B时间段)后三十秒访问了9900个请求.这个符合限流要求.
   但是假如在下一个(C时间段)固定窗口的前三十秒访问了5000个请求,(D时间段)后三十秒访问了5000个请求,这个窗口符合限流要求
   但是 B+C 这个时间段 也是一分钟,就不符合限流要求了.
   这就有了滑动窗口,相比固定窗口来说,控制精度会更细,但是没有固定窗口效率高,二者在不同的业务场景下,需要根据不通的业务需求进行选择.
  
# 滑动窗口

   *滑动窗口 
   主要是不再固定窗口,而是将时间段划分几个小的窗口.
   ```
   segmentInteval := fillInteval.Seconds() / float64(segmentNum) // fillInteval.Seconds()  总的时间范围 10000请求/分钟 表示一分钟 计算每一个小的窗口大小
   tick := float64(time.Now().Unix()) / segmentInteval
   ```
   将时间范围划分n个小窗口,将每个小窗口的值记录下来,每次循环统计 当前的小窗口 + 前(n-1)个窗口记录的值.
   
   这里总是和之前的窗口进行组合对比,每次滑动的是一个小的窗口.这就保证了滑动窗口流量不会遗漏,也就不存在时间上下段次数溢出的异常.
   
   口 口 口 口
   -------    这条线代表就是频率的范围的固定大小, 每次向前滑动,滑动的是一个小窗口
   