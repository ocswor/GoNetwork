# 固定窗口控制

## 限流
   * 限制对象的访问次数 比如1000次/秒，10000/分钟, 1分钟就是窗口的大小
   
## 窗口的划分
   

   * 将1970年到现在的时间当做一条线.
        
      ```
     println(time.Now().Unix()) 表示当前的时间总数  
     r := int64(time.Now().Unix() / int64(fillInterval.Seconds())) // 表示当前属于哪个窗口
      ```  
     假如每一个窗口的大小固定,那么在这条线线上的某一秒属于的某个窗口就是固定的
     
     将窗口的时间段转化成一个key值. 通过redis记录key值,就可以记录当前窗口范围内访问的个数.
     
## 固定窗口的缺点
   因为窗口一旦固定住了,而请求时间不固定.
   假如一个 限流要求是  10000请求/分钟
   假如一个一个固定窗口的(A时间段)前30秒访问了100个请求,(B时间段)后三十秒访问了9900个请求.这个符合限流要求.
   但是假如在下一个(C时间段)固定窗口的前三十秒访问了5000个请求,(D时间段)后三十秒访问了5000个请求,这个窗口符合限流要求
   但是 B+C 这个时间段 也是一分钟,就不符合限流要求了.
   这就有了滑动窗口,相比固定窗口来说,控制精度会更细,但是没有固定窗口效率高,二者在不同的业务场景下,需要根据不通的业务需求进行选择.
  
# 滑动窗口

   *滑动窗口 
   主要是不再固定窗口,而是将时间段划分几个小的窗口.
   ```
   segmentInteval := fillInteval.Seconds() / float64(segmentNum) // fillInteval.Seconds()  总的时间范围 10000请求/分钟 表示一分钟 计算每一个小的窗口大小
   tick := float64(time.Now().Unix()) / segmentInteval
   ```
   将时间范围划分n个小窗口,将每个小窗口的值记录下来,每次循环统计 当前的小窗口 + 前(n-1)个窗口记录的值.
   
   这里总是和之前的窗口进行组合对比,每次滑动的是一个小的窗口.这就保证了滑动窗口流量不会遗漏,也就不存在时间上下段次数溢出的异常.
   
   口 口 口 口
   -------    这条线代表就是频率的范围的固定大小, 每次向前滑动,滑动的是一个小窗口


# 令牌桶限流 限流算法

   * 什么是令牌同限流
   令牌桶算法是一个桶，匀速向桶里放令牌，控制桶最大容量（令牌最大数）和放入令牌速率（生成令牌/秒）。请求从桶中拿令牌，拿到令牌可以通过，拿不到就被限流了。
   
   可以用一个队列表示这个桶,一个有容量的桶
   启动一个任务匀速的向这个队列中放令牌,直到桶满了为止
   当访问量小时，令牌桶可以积累令牌到桶满，每次访问都可以拿到令牌。
   而当短时突发流量，积累的令牌能保障大量请求可以立刻拿到令牌，令牌用完了，请求会依赖于新令牌申请速度，这时会退化成类似漏斗桶算法。
   
   我们可以模拟这个桶，不断的操作这个桶，这个桶可以是list,也可以是其他队列，但是这种不断操作，比较耗费内存，增加不必要的开销
   可以通过实时算法计算的方式来计算可用令牌数。
   公式 **可用令牌数=（当前请求时间-上次请求时间）*令牌生成速率 + 上次使用后剩余令牌数**  比如：1分钟内可以通过1000个请求 
   ```
    rate := float64(limitNum) / float64(fillInterval.Seconds()) // 速率就是 1000/60
   ```
   需要记录一下上次请求的时间和上次使用后剩余令牌数  我们就可以根据上面计算公式得到 *剩余的令牌数*
   如果可用令牌数 > 0代表有令牌，就可以通过，
   假如剩余令牌数-1，并更新保存本次剩余令牌数和本次请求时间用于下次计算，这种方式也是惰性加载/计算的一种体现。
   